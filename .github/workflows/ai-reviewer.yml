# .github/workflows/ai-reviewer.yml

name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

# Permissions are updated to allow writing content (for the review comment)
# and id-token (for authentication).
permissions:
  contents: write # Changed from read to write to allow committing doc updates
  pull-requests: write
  id-token: write

jobs:
  ai-review:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout code'
        uses: 'actions/checkout@v4'
        # We need to fetch the full history to compare branches and apply diffs
        with:
          fetch-depth: 0 
          ref: ${{ github.head_ref }}

      - name: 'Authenticate to Google Cloud'
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          audience: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}

      - name: 'Set up Google Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: 'Generate Diff and Call AI'
        id: ai_review_step
        run: |
          # Get the diff of the pull request
          PR_DIFF=$(git diff origin/${{ github.base_ref }} ${{ github.head_ref }})

          # Prepare the prompt for the Gemini API
          # This is where we instruct the AI to return a JSON object
          PROMPT_TEXT=$(cat <<EOF
          You are an expert AI software architect reviewing a pull request.
          Analyze the following code changes (git diff) and compare them against our project documentation.
          Your response MUST be a single JSON object with two keys: "reviewComment" (a string with your human-readable review) and "docUpdates" (an array of objects, each with "filePath" and "patch" keys).
          The "patch" value must be a valid diff patch that can be applied with the 'git apply' command. If no documentation changes are needed, return an empty array for "docUpdates".

          CONTEXT (Project Documentation will be fetched here via RAG in a real implementation)
          ---
          [Placeholder for RAG context from Vertex AI Search]
          ---
          
          GIT DIFF:
          ---
          ${PR_DIFF}
          ---
          EOF
          )
          
          # Call the Gemini API (this is a placeholder for the actual gcloud command)
          # The real command would pass the PROMPT_TEXT to the model
          AI_RESPONSE='{
            "reviewComment": "This is a great start. The new component follows our architectural principles. I have identified one section in `06 - Functional Specification.txt` that needs to be updated to reflect this new feature. I am applying the patch automatically.",
            "docUpdates": [
              {
                "filePath": "Instructions/06 - Functional Specification.txt",
                "patch": "--- a/Instructions/06 - Functional Specification.txt\n+++ b/Instructions/06 - Functional Specification.txt\n@@ -1,3 +1,5 @@\n+## New Feature Section\n+\n This is a new line added to the documentation automatically.\n ## **Match Overview & Summary**\n \n To provide the AVAR with a clear, at-a-glance visual overview of all critical match information, a dedicated **\"Match Summary\"** module will be present on the main dashboard. This module is read-only and provides a live summary of the match state."
              }
            ]
          }'

          # Use a heredoc to safely handle multiline JSON and set it as a GitHub Action output
          cat <<EOF > ai_response.json
          ${AI_RESPONSE}
          EOF
          echo "ai_response_json=$(cat ai_response.json | jq -c .)" >> $GITHUB_OUTPUT

      - name: 'Post Review Comment'
        run: |
          REVIEW_COMMENT=$(echo '${{ steps.ai_review_step.outputs.ai_response_json }}' | jq -r .reviewComment)
          gh pr comment ${{ github.event.pull_request.number }} --body "$REVIEW_COMMENT"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 'Apply Documentation Updates'
        if: fromJson(steps.ai_review_step.outputs.ai_response_json).docUpdates[0] != null # Only run if there are updates
        run: |
          echo "Applying documentation updates..."
          
          # Configure Git
          git config user.name "AVAR Assistant AI"
          git config user.email "ai-assistant@example.com"
          
          # Loop through each documentation update from the AI's response
          echo '${{ steps.ai_review_step.outputs.ai_response_json }}' | jq -c '.docUpdates[]' | while read -r update; do
            FILE_PATH=$(echo "$update" | jq -r .filePath)
            PATCH_CONTENT=$(echo "$update" | jq -r .patch)
            
            echo "Applying patch to ${FILE_PATH}..."
            echo -e "${PATCH_CONTENT}" > doc_update.patch
            
            if git apply --check doc_update.patch; then
              git apply doc_update.patch
              git add "${FILE_PATH}"
            else
              echo "Error: Patch could not be applied cleanly."
              # You could add more robust error handling here, like posting a failure comment
              exit 1
            fi
            rm doc_update.patch
          done
          
          # Commit and push the changes
          if ! git diff --staged --quiet; then
            git commit -m "docs: AI-generated documentation updates"
            git push origin ${{ github.head_ref }}
          else
            echo "No documentation changes to commit."
          fi
